def find_optimal_strategy(cards):
    n = len(cards)
    # Create a memoization table to store subproblem results
    dp = [[0] * n for _ in range(n)]

    # Fill the table for subproblems of increasing sizes
    for length in range(1, n+1):
        for i in range(n-length+1):
            j = i + length - 1
            # If only one card is left, the player takes it
            if i == j:
                dp[i][j] = cards[i]
            else:
                # Choose the best of two choices:
             # 1. Take the left card, and the opponent plays optimally on the remaining (i+1, j)
            # 2. Take the right card, and the opponent plays optimally on the remaining (i, j-1)
                take_left = cards[i] - dp[i+1][j]
                take_right = cards[j] - dp[i][j-1]
                dp[i][j] = max(take_left, take_right)
    # dp[0][n-1] will have the optimal score difference for the first player
    return (dp[0][n-1] + sum(cards)) // 2  # First player's maximum possible score
# Example case
cards = [3, 9, 1, 2]
print("First player's optimal score:", find_optimal_strategy(cards))
